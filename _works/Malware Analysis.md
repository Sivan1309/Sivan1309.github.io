---
title: Malware Research & Hands-On Lab Analysis â€” Static, Dynamic & Reverse Engineering of PDF, PE and DLL Samples
date: 2024-02-23
---

# Malware Under the Microscope: Hands-On Static, Dynamic & Reverse Engineering Analysis

---

## Executive Summary

This project documents a hands-on malware research investigation covering static analysis, dynamic analysis, packed binary inspection, DLL behavioral analysis, and reverse engineering across multiple suspicious samples including PDFs, PE executables, and DLL files.

The objective of this project was to simulate a real-world malware triage and research workflow â€” starting from file triage and structure inspection through behavioral execution, capability mapping, and MITRE ATT&CK alignment â€” using industry malware analysis tooling and controlled sandbox environments.

The outcome includes malicious sample confirmation, behavioral capability mapping, persistence discovery, network indicators, and reverse-engineered execution traits.

This project demonstrates applied skills in:

- Malware static & dynamic analysis
- Packed binary investigation
- PDF malware inspection
- DLL behavioral analysis
- Registry & persistence tracing
- Network traffic analysis
- Capability detection using CAPA
- MITRE ATT&CK mapping
- Reverse engineering fundamentals

---

## Investigation Objective

The objective was not just classification â€” but **evidence-driven determination of malicious behavior** using:

- Static structure analysis
- Packed binary inspection
- Behavioral execution tracing
- Registry & persistence validation
- Network traffic analysis
- Capability mapping
- Reverse engineering verification

Every conclusion is supported by tool output evidence and analyst interpretation.

---

## Investigation Methodology

The workflow followed a layered analyst investigation model:

```

Triage
â†’ Static Structure Inspection
â†’ Indicator Extraction
â†’ Packing Detection
â†’ Unpacking
â†’ Behavioral Execution
â†’ Host Impact Measurement
â†’ Network Impact Measurement
â†’ Capability Mapping
â†’ Reverse Engineering Validation
â†’ Detection Translation

````

---

## Lab Environment

Analysis performed in isolated malware lab VMs.

- REMnux analysis distro
- Windows malware analysis VM
- VirtualBox isolated network
- Snapshot rollback enabled
- Controlled execution only
- Sandbox validation used for network behavior

<img width="1490" height="998" alt="Image" src="https://github.com/user-attachments/assets/f45d9da0-5f52-405a-84cc-3233a40c62de" />

---

## Sample Scope

| Sample          | Type    | Investigation Focus                  |
|-----------------|---------|--------------------------------------|
| CW_sample1â€“3    | PDF     | Embedded script & execution triggers |
| suspicious.file | PE EXE  | Packed malware behavior              |
| malsample.dll   | DLL     | Persistence & service abuse          |

---

# Phase 1 â€” Malicious PDF Investigation

## Analyst Goal

Determine whether PDFs contain execution triggers or embedded scripts **without executing them**.

---

## Raw Structure Inspection

## Initial File Integrity â€” Hash Generation (PDF Samples)

Before starting the analysis, cryptographic hashes were generated for each PDF sample to create a unique fingerprint and preserve file integrity.

```bash
md5sum CW_sample1.pdf
md5sum CW_sample2.pdf
md5sum CW_sample3.pdf

sha256sum CW_sample1.pdf
sha256sum CW_sample2.pdf
sha256sum CW_sample3.pdf
````

### Why This Step Is Important

* Creates a unique and verifiable file identity
* Avoids accidental sample confusion
* Allows safe reputation checks via hash lookup
* Supports IOC documentation and reporting
* Aligns with standard malware analysis workflow

---

## VirusTotal Lookup â€” Reputation Verification

Instead of uploading the files, their hashes were queried in VirusTotal to check detection reputation safely.

### Observed Lab Results

<img width="1974" height="810" alt="Image" src="https://github.com/user-attachments/assets/0dc57a96-b56f-48a7-90d0-cdc85ac6c72b" />

<img width="1982" height="1152" alt="Image" src="https://github.com/user-attachments/assets/952e6492-fc93-402f-bdbb-cdba49de6f41" />

| Sample         | Detection Count | Interpretation |
| -------------- | --------------- | -------------- |
| CW_sample1.pdf | Low / None      | Likely benign  |
| CW_sample2.pdf | 47 vendors      | Malicious      |
| CW_sample3.pdf | 43 vendors      | Malicious      |

### Analyst Note

Detection ratios provide supporting signals, not definitive proof. Final conclusions were based on static file structure analysis and embedded behavior indicators.

---

**Tool:** SciTE

**Purpose:** Inspect encoded streams safely

<img width="652" height="1168" alt="Image" src="https://github.com/user-attachments/assets/761f49c1-b56d-4b9e-adea-ca8acfa2f8d5" />

**Observation**

Encoded object streams present â†’ requires structural scanning.

**Decision:** Escalate to structural indicator scan.

---

## Structural Trigger Scan

**Tool:** PDFiD

```bash
pdfid.py CW_sample1.pdf
pdfid.py CW_sample2.pdf
pdfid.py CW_sample3.pdf
```

<img width="1762" height="1242" alt="Image" src="https://github.com/user-attachments/assets/e750f0fa-16b1-46a1-b229-a14e0199ac40" />

**Evidence**

* /JavaScript present
* /OpenAction present
* /AA present

---

## Phase 1.1 - Further Analysis with peepdf

peePDF was used after PDFiD to enumerate objects and detect hidden components.

**Launch peePDF**

```bash
peepdf CW_sample1.pdf
peepdf CW_sample2.pdf
peepdf CW_sample3.pdf
```

**Enumerate Objects Inside peePDF Console**

<img width="1758" height="1056" alt="Image" src="https://github.com/user-attachments/assets/abfd6faf-bbdc-4df0-94ca-493b38f36838" />
<img width="2068" height="1076" alt="Image" src="https://github.com/user-attachments/assets/e671a254-7b4e-4cef-b2c5-9e6418e6fd26" />

**Inside peePDF interactive shell:**

```bash
objects
```

**Why This Command**

* Lists all object IDs
* Identifies encoded objects
* Flags suspicious streams
* Reveals embedded files
* Shows JavaScript objects

**Analyst Interpretation**

* Presence of decode filters indicates:

  * compressed payload
  * encoded script
  * obfuscated content
  * hidden executable stream

After analyzing all samples using peePDF, the internal PDF objects were successfully enumerated and reviewed. Based on the suspicious objects identified through peePDF and PDFiD, targeted follow-up analysis was performed using pdf-parser to extract and decode the specific objects for deeper inspection.

---

## Object Decoding Validation

**Tool:** PDF-Parser

<img width="1964" height="672" alt="Image" src="https://github.com/user-attachments/assets/52706550-f8ae-4e15-84ab-7879175748ec" />

<img width="1962" height="946" alt="Image" src="https://github.com/user-attachments/assets/f9f54002-64a2-40c7-a4e8-fbe8f3a1665b" />

<img width="1954" height="924" alt="Image" src="https://github.com/user-attachments/assets/4100809f-1929-4b75-ba32-58117e260342" />

Decoded object confirmed embedded JavaScript execution logic.

---

## PDF Verdicts

| Sample  | Verdict   | Reason                    |
| ------- | --------- | ------------------------- |
| Sample1 | Benign    | No execution triggers     |
| Sample2 | Malicious | JS + OpenAction           |
| Sample3 | Malicious | External JS communication |

---

# Phase 2 â€” Packed Executable Analysis

## Analyst Goal

Determine whether binary is packed and hiding malicious logic.

---

## PE Structure Inspection

**Tool:** PEView

<img width="1754" height="1296" alt="Image" src="https://github.com/user-attachments/assets/cd282d34-250a-41b7-88d0-340938a0d938" />

**Evidence**

* UPX0 / UPX1 sections
* Packed layout signature

**Analyst Interpretation**

These indicators validate the file format and structure as a legitimate PE executable. However, these characteristics alone do not indicate maliciousness. They only establish that the file is a Windows executable and suitable for further malware-focused analysis. But the section UPX0 and UPX1 confirm this file is packed.

---

## Packer Identification

**Tool:** Exeinfo PE

<img width="1686" height="746" alt="Image" src="https://github.com/user-attachments/assets/9e963ac5-9695-44c1-b6e8-81ab0d7490bc" />

Confirmed packed with UPX.

---

## Controlled Unpacking

```bash
upx -d suspicious.file
```

<img width="1746" height="504" alt="Image" src="https://github.com/user-attachments/assets/cef3216b-f83c-4fc3-9c9e-403484d52610" />

Status check confirmed that the packed file is .text format.

<img width="1652" height="748" alt="Image" src="https://github.com/user-attachments/assets/18c80ec5-f513-4364-85dc-e69c37ac5f25" />

---

# Static Capability Profiling â€” API, Strings & Function Call Correlation

**Tool:** Pestudio

To determine whether the packed executable demonstrated malicious intent beyond structural anomalies, I performed deep static capability profiling using PEStudio. Instead of relying on single indicators, I correlated three layers of static evidence:

- Blacklisted API imports  
- High-signal embedded strings  
- Blacklisted function call references  

The objective was to infer behavioral capability from code-level dependencies and validate whether the executable aligns with known malware tradecraft patterns.

This section documents how these signals combine to support a malicious classification.

---

## Layer 1 â€” Blacklisted API Import Analysis

PEStudio import analysis revealed a dense cluster of high-risk Windows API calls across privilege, registry, file system, execution, and clipboard domains. The significance comes from **capability grouping**, not individual API presence.

<img width="1758" height="1112" alt="Image" src="https://github.com/user-attachments/assets/c0e1083c-ba07-45f2-a8f7-1d21345e8580" />

## Privilege & Token Manipulation APIs Observed

- OpenProcessToken  
- LookupPrivilegeValue  
- AdjustTokenPrivileges  

**Analyst Interpretation**

These APIs allow a program to modify its security token and elevate privileges. This capability is frequently used by malware to enable debug rights, access protected processes, and bypass security controls. Standard user applications rarely adjust privileges programmatically.

---

## Registry Modification APIs Observed

- RegSetValueEx  
- RegDeleteKey  
- RegDeleteValue  
- RegEnumKey  
- WritePrivateProfileString  

**Analyst Interpretation**

These functions enable registry persistence, autorun configuration, and system setting modification. This supports persistence and configuration tampering capability and aligns with later dynamic registry change observations.

---

## File System Manipulation APIs Observed

- WriteFile  
- MoveFile / MoveFileEx  
- DeleteFile  
- SetFileAttributes  
- RemoveDirectory  
- GetTempFileName  
- FindFirstFile / FindNextFile  

**Analyst Interpretation**

This cluster supports payload staging, temporary file creation, file replacement, cleanup operations, and attribute hiding. These are commonly observed in droppers and loader malware families.

---

## Process Execution APIs Observed

- CreateProcess  
- ShellExecute  
- GetExitCodeProcess  

**Analyst Interpretation**

These APIs allow execution of secondary payloads and command chains. This strongly indicates loader behavior and staged execution capability.

---

## Clipboard Interaction APIs Observed

- OpenClipboard  
- SetClipboardData  
- EmptyClipboard  
- CloseClipboard  

**Analyst Interpretation**

Clipboard interaction is often associated with credential theft, data interception, or crypto hijacking. While not malicious by itself, it is uncommon in background executables and increases suspicion when combined with other attacker capabilities.

---

## Layer 2 â€” Embedded String Intelligence

String extraction revealed multiple high-signal artifacts that provide insight into packaging style and behavioral intent.

<img width="1532" height="430" alt="Image" src="https://github.com/user-attachments/assets/b3d86db3-cabd-41a4-8916-75a690b52220" />

## Installer / NSIS Style Strings Detected

Examples observed:

- Installer integrity check has failed  
- Error writing temporary file  
- NSIS Error  

**Analyst Interpretation**

These strings indicate NSIS-style packaging, commonly used by malware droppers and staged loaders. This supports the packed dropper hypothesis established earlier in the analysis.

---

## ðŸ—„ Registry Path Strings Detected

Examples observed:

- Software\Microsoft\Windows\CurrentVersion  
- Control Panel paths  
- Quick Launch references  

**Analyst Interpretation**

These confirm registry targeting awareness and persistence path knowledge. This string evidence directly supports the registry modification API cluster.

---

## Configuration & Manifest Strings

Embedded XML assembly manifest strings were present, indicating structured packaging and installer-style wrapping. While not malicious alone, this is consistent with staged payload design.

---

## Layer 3 â€” Blacklisted Function Call Clustering

The blacklisted function call view shows capability clustering across multiple attacker behavior domains.

<img width="1574" height="1252" alt="Image" src="https://github.com/user-attachments/assets/ac03fe52-c540-44fb-841f-3c61b8e088d2" />

## High-Risk Functional Groups Present

- Privilege escalation functions  
- Registry persistence functions  
- File staging and manipulation functions  
- Process execution functions  
- Environment modification functions  
- System control functions  
- Special folder discovery functions  

**Analyst Interpretation**

Malware classification is supported when multiple attacker capabilities appear together. The simultaneous presence of privilege manipulation, persistence mechanisms, payload execution, and environment control is inconsistent with simple benign utilities.

---

## Cross-Evidence Correlation

These static findings were validated through correlation with other analysis layers:

- UPX packing confirmed  
- Successful unpacking required  
- Blacklisted imports detected  
- Registry persistence observed dynamically  
- Service creation observed dynamically  
- CAPA malicious capability matches  
- Sandbox behavioral indicators present  

Static and dynamic evidence alignment significantly increases classification confidence.

---

## Analyst Conclusion

No single API, string, or blacklist flag proves maliciousness independently. However, the combined capability profile â€” privilege manipulation, registry persistence, payload staging, process execution, and installer-style packaging â€” forms a coherent malicious behavior model. When correlated with unpacking results and dynamic host evidence, this supports classification of the executable as malicious.

# Phase 3 â€” DLL Malware Behavioral Analysis

## Analyst Goal

Determine persistence and execution behavior of DLL payload.

---

## Controlled DLL Execution

```bash
rundll32.exe malsample.dll,Install
```
<img width="1470" height="920" alt="Image" src="https://github.com/user-attachments/assets/a8230251-b5da-42b3-95f9-826517456a9e" />

<img width="1516" height="1272" alt="Image" src="https://github.com/user-attachments/assets/c8e59758-bfec-4541-9507-a6eb6835d5d3" />

**Analyst Interpretation**

Execution of malsample.dll was performed under controlled conditions, and background function activity was monitored using Sysinternals instrumentation tools. During the observation window, no malicious execution behavior was triggered on the host.

Validation was conducted using Process Monitor and Wireshark telemetry. No process creation events, module load activity, or execution traces associated with malsample.dll were recorded within the monitored timeframe. Network analysis further showed no inbound or outbound communication originating from the Windows workstation during execution monitoring.

---

## Registry Impact Measurement

**Tool:** Regshot (before/after diff)

<img width="2264" height="1016" alt="Image" src="https://github.com/user-attachments/assets/c4d58255-411d-46fb-98da-3df794883f8b" />

# ðŸ”¬ Registry Impact Analysis â€” Service-Based Persistence Evidence

The Regshot before/after comparison shows that execution of `malsample.dll` resulted in the creation of multiple new registry keys under the Windows **Services** registry hive. These additions are not normal side effects of benign DLL execution and indicate persistence-oriented system modification.

---

## Key Registry Artifacts Observed

## New Service Registry Keys Created

The diff shows new keys under:

HKLM\SYSTEM\ControlSet001\Services\IPRIP  
HKLM\SYSTEM\CurrentControlSet\Services\IPRIP

### Analyst Interpretation

Creation of a new subkey under `Services` indicates that the DLL registered itself as a **Windows service component**. This is a persistence mechanism that allows code to be loaded automatically by the Service Control Manager during system startup.

Legitimate software installs services through signed installers and visible setup routines â€” not through silent DLL execution during malware lab runtime.

---

## Malicious Service DLL Registration

## Critical Value Observed

Parameters\ServiceDll =  
C:\Documents and Settings\admin\Desktop\Samples\malsample.dll

### Why This Is High Risk

This registry value explicitly instructs Windows to load the DLL as a **service module** under the svchost service host process.

This means:

- DLL becomes service-backed code  
- Code executes via svchost  
- Execution blends with legitimate system services  
- Detection difficulty increases  
- Persistence survives reboot  

This is a well-known malware persistence technique: **service DLL registration persistence**.

---

## svchost Hosting Behavior Observed

## Registry Value Present

ImagePath = %SystemRoot%\System32\svchost.exe -k netsvcs

### Analyst Meaning

The service is configured to run under:

svchost.exe -k netsvcs

This is a shared service host group used by many legitimate services. Malware commonly hides inside this group to:

- blend with system activity  
- avoid process-name detection  
- inherit service-level privileges  
- reduce suspicion  

---

## Service Configuration Fields Added

Observed fields include:

- Type  
- Start  
- ErrorControl  
- ObjectName = LocalSystem  
- DependOnService = RpcSs  

### Analyst Interpretation

These fields indicate a fully structured service registration â€” not a temporary registry artifact.

Notable risk signals:

- Start value present â†’ enables automatic or service-triggered startup  
- ObjectName = LocalSystem â†’ service runs with highest local privilege  
- DependOnService = RpcSs â†’ integrates into core Windows service chain  

This shows deliberate persistence configuration.

---

## Why This Registry Behavior Is Malicious

This registry pattern is malicious because it demonstrates:

## Persistence Mechanism

- New service created  
- DLL linked as ServiceDll  
- Auto-load path defined  
- Survives reboot  

---

## Privilege Escalation Surface

- Runs under svchost  
- Uses LocalSystem context  
- Gains service-level execution  

---

## Defense Evasion

- Blends with netsvcs group  
- Avoids new standalone process visibility  
- Appears as legitimate service host activity  

---

## Covert Execution Model

Earlier execution monitoring showed no direct interactive DLL process execution. Service-based loading explains the absence of a standalone process tree, since execution occurs inside svchost.

---

## Correlation With Earlier Findings

This registry persistence behavior aligns with previously observed static capabilities:

- Registry modification APIs present  
- Service-related APIs imported  
- Privilege adjustment APIs present  
- Packed executable delivery model  
- Dropper-style string indicators  

Static capability â†’ registry persistence â†’ behavioral confirmation.

## Analyst Conclusion

The registry diff confirms creation of a new Windows service entry that registers the analyzed DLL as a service module loaded by svchost under the netsvcs group. This establishes a service-based persistence mechanism with elevated execution context. Such behavior is not expected from benign DLL execution and represents a known malware persistence technique. This registry impact provides behavioral confirmation of malicious intent.


# Phase 4 â€” Network Behavior Analysis

**Tool:** Wireshark + Sandbox PCAP

ðŸ“¸ Evidence â€” DNS Beacon Queries
`screenshots/wireshark_dns.png`

**Observed**

* DNS beaconing
* HTTP GET callbacks
* Periodic traffic interval
* Mutex creation event

**Interpretation**

C2 beacon behavior pattern.

---

# Phase 5 â€” Capability Mapping

**Tool:** CAPA

ðŸ“¸ Evidence â€” CAPA Capability Matches
`screenshots/capa_capabilities.png`

**Capabilities Detected**

* Service persistence
* Registry modification
* Network communication
* Execution delay logic

---

# MITRE ATT&CK Mapping

ðŸ“¸ Evidence â€” ATT&CK Technique Mapping
`screenshots/mitre_mapping.png`

**Mapped behaviors**

* Persistence â€” Service install
* Registry modification
* Command execution
* Beacon communication

---

# Phase 6 â€” Reverse Engineering Validation

## Export Table Analysis

ðŸ“¸ Evidence â€” DLL Export Functions
`screenshots/dll_exports.png`

Total exports: **5**

---

## Execution Delay Behavior

ðŸ“¸ Evidence â€” Sleep Call Graph
`screenshots/sleep_graph.png`

Sleep parameter:

```
0xEA60 = 60000 ms
```

Interpretation: Sandbox evasion delay.

---

# Analyst Decision Log

* Encoded PDF streams detected â†’ escalated to structural scan
* Execution triggers found â†’ object decoding performed
* UPX sections detected â†’ unpacked before IOC extraction
* DLL lacked entry point â†’ executed via rundll32 install export
* Persistence suspected â†’ registry diff performed
* Behavior unclear â†’ CAPA capability mapping used
* Delay behavior observed â†’ reverse engineering confirmed

---

# Adversary Tradecraft Observed

* Packing for evasion
* Service persistence
* Registry modification
* Execution delay anti-sandbox
* Embedded document script triggers
* Beacon callback behavior

---

# Detection Engineering Opportunities

* rundll32 service install monitoring
* Registry service key alerts
* Packed binary heuristics
* PDF OpenAction scanning
* Beacon interval detection
* Mutex creation alerts
* CAPA rule automation

---

# Reproduce This Investigation

1. Load sample into REMnux
2. Run `pdfid.py`
3. Decode objects with pdf-parser
4. Inspect PE headers
5. Detect packer
6. Unpack with UPX
7. Run Pestudio
8. Capture Regshot before/after
9. Execute via rundll32
10. Capture PCAP
11. Run CAPA
12. Validate via reverse engineering

---

# Skills Demonstrated

* Static malware analysis
* PDF exploit inspection
* Packed binary unpacking
* DLL behavioral analysis
* Registry forensics
* Network IOC extraction
* Capability mapping
* MITRE ATT&CK translation
* Reverse engineering validation
* Detection engineering thinking

```
```
